/*  
 * puzzel_ABC.idp
 * Jelle Caerlen & Pieter-Jan Steeman
 */

/*
 * Regels: 
 *	- per rij en kolom 1 keer A, B en C
 *	- letters langs de kant geven dichtstbijzijnde letter aan
 */

vocabulary V {
    type Row isa int
    type Column isa int
    type Letter
    
    Solution(Row, Column, Letter)
    
    RowUpperKnown(Row, Letter)
    RowLowerKnown(Row, Letter)
    ColumnLeftKnown(Column, Letter)
    ColumnRightKnown(Column, Letter)
    
}

structure S : V {
 	Letter = {A; B; C;}  
    Row = {1 .. 4}
    Column = {1 .. 4}
    
    RowUpperKnown = {
        (4, C);
    }
    
    RowLowerKnown = {
        (1, B); (3, A);
    }
    
    ColumnLeftKnown = {
        (2, C); (4, C)
    }
    
    ColumnRightKnown = {
        (3, A);
    }
}

theory T : V {
    // Max 1 letter per vakje
    !row, col: 1 >= #{let[Letter]: Solution(row, col, let)}.
    
    // Elke kolom bevat exaxt 1 keer A, B and C
   	!col, let:#{row: Solution(row, col, let)} = 1.
    
    // Elke rij bevat exaxt 1 keer A, B and C
    !row, let:#{col: Solution(row, col, let)} = 1.
    
    //!row : ?let2: RowUpperKnown(row, let) => ((col = 1 | (col > 1 & ~Solution(row, 1, let2))) <=> Solution(row, col, let)).
    
    //?row : RowUpperKnown(row, let) => (?col1: !col2, let2 : (~Solution(row, col2, let2) & col1 > col2) => Solution(row, col1, let)).
   	//?row : RowLowerKnown(row, let) => (?col1: !col2, let2 : (~Solution(row, col2, let2) & col1 < col2) => Solution(row, col1, let)).
        
    //!row, col2, let2: ?col1: (RowUpperKnown(row, let) & col2 < col1 & ~Solution(row, col2, let2)) => Solution(row, col1, let).
    //!row, col2, let2: ?col1: (RowLowerKnown(row, let) & col2 > col1 & ~Solution(row, col2, let2)) => Solution(row, col1, let).
    
    //!row, let1, let2 : ?col: RowKnown(row, 1, let1) => Solution(row, 1, let1) | (Solution(row, col, let1) & ~Solution(row, col-1, let2)).
    
    //!row, let1, let2 : ?col: RowKnown(row, 4, let1) => Solution(row, 4, let1) | (Solution(row, col, let1) & ~Solution(row, col+1, let2)).
    
    !row, let1, let2: RowUpperKnown(row, let1) => Solution(row, 1, let1) | (Solution(row, 2, let1) & ~Solution(row, 1, let2)).

    !row, let1, let2: RowLowerKnown(row, let1) => Solution(row, 4, let1) | (Solution(row, 3, let1) & ~Solution(row, 4, let2)).
    
    
    //!col, let1, let2 : ?row: ColumnKnown(1, col, let1) & row = 2 => Solution(1, col, let1) | (Solution(row, col, let1) & ~Solution(row-1, col, let2)).
    
    //!col, let1, let2 : ?row: ColumnKnown(4, col, let1) & row = 3 => Solution(4, col, let1) | (Solution(row, col, let1) & ~Solution(row+1, col, let2)).
    
    !col, let1, let2: ColumnLeftKnown(col, let1) => Solution(1, col, let1) | (Solution(2, col, let1) & ~Solution(1, col, let2)).

    !col, let1, let2: ColumnRightKnown(col, let1) => Solution(4, col, let1) | (Solution(3, col, let1) & ~Solution(4, col, let2)).
}

procedure main() {
    stdoptions.nbmodels = 0
    printmodels(modelexpand(T,S))
}